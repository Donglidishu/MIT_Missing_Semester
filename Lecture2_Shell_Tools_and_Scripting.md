## `space` 
**空格用于分割命令**
如图所示，有空格会提示命令不存在：
![](./png_md/PixPin_2025-02-23_15-50-25.png)

---

## `"" 和 '' ` 
`""双引号` 允许拓展，如变量替换、命令替换、转义字符
`''单引号` 严格禁止拓展，完全保留原始字符串
![](./png_md/PixPin_2025-02-23_16-19-29.png)

---
## `$`
### 替换示例1
使用vim编辑一个函数 `mcd.sh` 
`vim mcd.sh` 之后按下i进入insert模式，编辑完成输入 `:wq` 保存并退出
![](./png_md/PixPin_2025-02-23_16-29-46.png)

使用 `source mcd.sh` 加载我们定义的函数，然后如图使用
![](./png_md/PixPin_2025-02-23_16-30-22.png)
此函数的作用是以传入的名称创建文件夹并cd到那个文件夹

### 替换示例2
`foo=$(pwd)` **将工作文件夹目录赋值给foo变量**
![](./png_md/PixPin_2025-02-24_11-29-34.png)

更一般的，可以使用 `echo "we are now in $(pwd)"` **注意使用双引号以支持拓展**
![](./png_md/PixPin_2025-02-24_11-31-17.png)

### 一些用法
#### `$0`
表示当前运行的脚本的名称

#### `$1 ~ $9`
表示当前脚本的第1~第9个参数
如果超过9个参数则需要使用花括号，如 `${10}`
#### `$#`
表示参数数量

#### `$_`
表示上一个命令的最后一个参数

#### `$?`
表示上一个命令的退出状态（返回值）
通常用于检查命令是否成功执行，返回 0 表示成功，非 0 值表示失败

#### `$$`
运行当前脚本的进程ID (PID)

#### `$!`
显示最近一次后台命令的PID

#### `$@`
所有传递给脚本的参数

---
## `!!`
用于引用并重新执行上一条命令
example: `mkdir /mnt/new` (可能提示permission denied)
此时可以使用 `sudo !!` 
此命令等同于 `sudo mkdir /mnt/new` 

---
## `grep`
用于查找文件中符合条件的文本行
语法: `grep content filename`
example: 
![](./png_md/PixPin_2025-02-24_01-09-18.png)

---
## `true & flase`
`true` 始终返回 **成功** 状态码（退出状态码为 0）
`false` 始终返回失败的 **退出** 状态码（非零值，通常是 1）

![](./png_md/PixPin_2025-02-24_01-19-22.png)

---
## `|| 和 &&`
"或" 和 "和" 
`||` 第一个命令通过则跳过第二个，否则执行第二个
example: 
![](./png_md/PixPin_2025-02-24_01-21-07.png)

`&&` 两个命令都通过才会执行，否则都不执行
example: 
![](./png_md/PixPin_2025-02-24_01-25-11.png)

---
## `;`
`;` 是命令分隔符，表示将多个命令串联起来执行，命令在 `;` 之前执行完后会继续执行 `;` 后的命令，不管前一个命令是否成功

---

## `cat <(ls) <(ls ..)`
**`<(ls)`**：这将执行 `ls` 命令，列出当前目录的内容，并通过进程替代的方式提供一个虚拟文件路径，表示当前目录的文件列表。

**`<(ls ..)`**：这将执行 `ls ..` 命令，列出父目录的文件和目录，同样通过进程替代提供一个虚拟文件路径，表示父目录的文件列表。

**`cat <(ls) <(ls ..)`**：cat 会读取这两个虚拟文件，并将它们的内容依次输出。

---


## `*`  **通配符**
`ls *.sh` 可列出以.sh结尾的文件

---

## `{}`
用法：如果需要输入例如 `cat test1.txt test2.txt test3.txt` 可以写成 `cat test{1,2,3}.txt` 并按回车，命令行将自动补全

---

## `convert`
ImageMagick 工具集中的一个命令行工具，用于图像处理、格式转换、编辑等任务
用法示例: `convert photo1.png photo1.jpg`
这里可以用 `{}` 拓展符: `covert photo1.{png,jpg}` 

---

## 关于脚本第一行指定解释器的代码(shebang / hashbang)
在脚本的第一行，通常使用 `#!`（称为 shebang 或 hashbang）来指定解释器。对于 Bash 脚本，第一行通常是：

```bash
#!/bin/bash
```

这行代码告诉操作系统使用 `/bin/bash` 来解释和执行这个脚本。具体来说：

- `#!` 是一个特殊的标记，表示这是一个解释器指令。
- `/bin/bash` 是 Bash 解释器的路径，操作系统会使用这个路径下的 Bash 来解释和执行脚本中的命令。

如果你使用的是其他 shell 或解释器，比如 `sh`、`python` 等，你可以相应地更改路径。例如：

- 对于 `sh` 脚本：`#!/bin/sh`
- 对于 Python 脚本：`#!/usr/bin/python3`

这个第一行的代码被称为 **shebang** 或 **hashbang**。

---

## shellcheck 脚本检查工具
安装shellcheck: 

```bash
brew install shellcheck
```

![](./png_md/PixPin_2025-02-26_00-43-03.png)

此工具可用于检查脚本中存在的错误，例如提示没有指定解释器、cd存在失败可能

在文件首行指定解释器bash，并修复cd失败可能导致的错误

![](./png_md/PixPin_2025-02-26_00-59-49.png)

再次使用shellcheck检查mcd.sh

![](PixPin_2025-02-26_01-01-17.png)

这次没有报错，说明检查通过

---

